{"name":"Collider","tagline":" Genericized Clojure collections for Java","body":"[![Build Status](http://img.shields.io/travis/rschmitt/collider.svg)](https://travis-ci.org/rschmitt/collider)\r\n[![Maven Central](https://img.shields.io/maven-central/v/com.github.rschmitt/collider.svg)](https://maven-badges.herokuapp.com/maven-central/com.github.rschmitt/collider)\r\n[![License](https://img.shields.io/github/license/rschmitt/collider.svg)](https://creativecommons.org/about/cc0)\r\n\r\n# Collider\r\n\r\nCollider is a tiny library that provides immutable persistent collections for\r\nJava. It does this by wrapping Clojure's collections in an object-oriented and\r\ntype-safe facade.\r\n\r\n## Examples\r\n\r\nCollider collections can be created by calling one of the factory methods in\r\nthe `Collider` class. The resulting collection can be used like any other\r\nunmodifiable Java collection--for instance, `ClojureList<T>` implements the\r\nstandard `java.util.List<T>` interface.\r\n\r\n```java\r\nList<String> myStrings = clojureList(\"a\", \"b\", \"c\");\r\nassertEquals(3, myStrings.size());\r\nassertEquals(\"a\", myStrings.get(0));\r\n```\r\n\r\nCollider collections can also be created by transforming another collection.\r\nThe technique of persistent modification is used to efficiently create modified\r\ncopies while leaving the immutable original untouched.\r\n\r\n```java\r\nClojureMap<String, String> emptyMap = clojureMap();\r\n\r\nClojureMap<String, String> assoc = emptyMap.assoc(\"key\", \"value\");\r\nassertTrue(assoc.containsKey(\"key\"));\r\nassertEquals(assoc.size(), 1);\r\nassertEquals(assoc.get(\"key\"), \"value\");\r\n\r\nClojureMap<String, String> dissoc = assoc.dissoc(\"key\");\r\nassertEquals(dissoc, emptyMap);\r\n```\r\n\r\nSince Collider specifically targets Java 8, not only can its collections be\r\nused with the Stream API, but they also include some convenience methods to\r\nmake common use cases (such as mapping a function over a list) more concise.\r\n\r\n```java\r\nClojureList<Integer> evens = clojureList(0, 2, 4, 6, 8);  // [0, 2, 4, 6, 8]\r\nClojureList<Integer> odds = evens.map(x -> x + 1);        // [1, 3, 5, 7, 9]\r\n```\r\n\r\nCollider also provides collectors that work with the Stream API.\r\n\r\n```java\r\nClojureList<Integer> singles = IntStream.range(0, 100).boxed().collect(toClojureList());\r\n```\r\n\r\nInternally, these collectors use Clojure's [transient\r\ncollections](http://clojure.org/transients) to efficiently accumulate a result.\r\nTransients are generally used as follows:\r\n\r\n1. Obtain a transient version of a collection from a persistent collection in\r\n   O(1) time\r\n2. Mutate the transient collection\r\n3. Turn the transient collection into a persistent collection in O(1) time\r\n\r\nCollider makes transients available directly. Continuing the above example:\r\n\r\n```java\r\nTransientList<Integer> tr = singles.asTransient();\r\nrange(100, 200).forEach(tr::append);\r\nClojureList<Integer> moreSingles = tr.toPersistent();\r\n\r\nassertEquals(moreSingles.size(), 200);\r\nassertEquals(moreSingles, range(0, 200).boxed().collect(toClojureList()));\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}